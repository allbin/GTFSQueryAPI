// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: query.sql

package storage

import (
	"context"
)

const getStopDepartures = `-- name: GetStopDepartures :many
select
    st.stop_id::text AS id,
    st.arrival_time::text AS arrival,
    st.departure_time::text AS departure,
    s.stop_name::text AS name,
    s.stop_lat::double precision AS lat,
    s.stop_lon::double precision AS lon,
    t.trip_headsign::text AS headsign,
    COALESCE(r.route_short_name, '')::text AS short_name,
    COALESCE(r.route_long_name, '')::text AS long_name
FROM
    stop_times st
        INNER JOIN stops s ON st.stop_id = s.stop_id
        INNER JOIN trips t ON st.trip_id = t.trip_id
        INNER JOIN routes r ON t.route_id = r.route_id
WHERE
    s.stop_id = $1
ORDER BY
    departure
limit $2::bigint
`

type GetStopDeparturesParams struct {
	StopID string
	Lim    int64
}

type GetStopDeparturesRow struct {
	ID        string
	Arrival   string
	Departure string
	Name      string
	Lat       float64
	Lon       float64
	Headsign  string
	ShortName string
	LongName  string
}

func (q *Queries) GetStopDepartures(ctx context.Context, arg GetStopDeparturesParams) ([]GetStopDeparturesRow, error) {
	rows, err := q.db.Query(ctx, getStopDepartures, arg.StopID, arg.Lim)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStopDeparturesRow
	for rows.Next() {
		var i GetStopDeparturesRow
		if err := rows.Scan(
			&i.ID,
			&i.Arrival,
			&i.Departure,
			&i.Name,
			&i.Lat,
			&i.Lon,
			&i.Headsign,
			&i.ShortName,
			&i.LongName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStops = `-- name: GetStops :many
select stop_id, stop_name, stop_lat, stop_lon, location_type, geom from stops limit 50
`

func (q *Queries) GetStops(ctx context.Context) ([]Stop, error) {
	rows, err := q.db.Query(ctx, getStops)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Stop
	for rows.Next() {
		var i Stop
		if err := rows.Scan(
			&i.StopID,
			&i.StopName,
			&i.StopLat,
			&i.StopLon,
			&i.LocationType,
			&i.Geom,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStopsNearby = `-- name: GetStopsNearby :many
select stop_id, stop_name, stop_lat, stop_lon, location_type, geom
from stops
where st_dwithin(
    geography(st_point(stop_lon, stop_lat)),
    geography(st_point($1::double precision, $2::double precision)),
    $3::double precision
)
order by st_distance(
    st_point(stop_lon, stop_lat),
    st_point($1::double precision, $2::double precision)
)
limit $4::bigint
`

type GetStopsNearbyParams struct {
	Lon    float64
	Lat    float64
	Radius float64
	Lim    int64
}

func (q *Queries) GetStopsNearby(ctx context.Context, arg GetStopsNearbyParams) ([]Stop, error) {
	rows, err := q.db.Query(ctx, getStopsNearby,
		arg.Lon,
		arg.Lat,
		arg.Radius,
		arg.Lim,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Stop
	for rows.Next() {
		var i Stop
		if err := rows.Scan(
			&i.StopID,
			&i.StopName,
			&i.StopLat,
			&i.StopLon,
			&i.LocationType,
			&i.Geom,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
