// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: query.sql

package storage

import (
	"context"
)

const getDeparturesForStops = `-- name: GetDeparturesForStops :many
SELECT st.stop_id::text                       AS id,
       cd.date::text                          AS date,
       st.arrival_time::text                  AS arrival,
       st.departure_time::text                AS departure,
       s.stop_name::text                      AS name,
       s.stop_lat::double precision           AS lat,
       s.stop_lon::double precision           AS lon,
       t.trip_headsign::text                  AS headsign,
       COALESCE(r.route_short_name, '')::text AS short_name,
       COALESCE(r.route_long_name, '')::text  AS long_name
FROM stop_times st
         INNER JOIN stops s ON st.stop_id = s.stop_id
         INNER JOIN trips t ON st.trip_id = t.trip_id
         INNER JOIN routes r ON t.route_id = r.route_id
         INNER JOIN calendar_dates cd ON t.service_id = cd.service_id
WHERE s.stop_id = ANY($1::text[])
  AND cd.date IN (current_date, current_date + interval '1 day')
ORDER BY date,
         departure
LIMIT $2::bigint
`

type GetDeparturesForStopsParams struct {
	StopID []string `json:"stop_id"`
	Lim    int64    `json:"lim"`
}

type GetDeparturesForStopsRow struct {
	ID        string  `json:"id"`
	Date      string  `json:"date"`
	Arrival   string  `json:"arrival"`
	Departure string  `json:"departure"`
	Name      string  `json:"name"`
	Lat       float64 `json:"lat"`
	Lon       float64 `json:"lon"`
	Headsign  string  `json:"headsign"`
	ShortName string  `json:"short_name"`
	LongName  string  `json:"long_name"`
}

func (q *Queries) GetDeparturesForStops(ctx context.Context, arg GetDeparturesForStopsParams) ([]GetDeparturesForStopsRow, error) {
	rows, err := q.db.Query(ctx, getDeparturesForStops, arg.StopID, arg.Lim)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDeparturesForStopsRow
	for rows.Next() {
		var i GetDeparturesForStopsRow
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Arrival,
			&i.Departure,
			&i.Name,
			&i.Lat,
			&i.Lon,
			&i.Headsign,
			&i.ShortName,
			&i.LongName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStop = `-- name: GetStop :one
select stop_id, stop_name, stop_lat, stop_lon, location_type, geom from stops where stop_id = $1
`

func (q *Queries) GetStop(ctx context.Context, stopID string) (Stop, error) {
	row := q.db.QueryRow(ctx, getStop, stopID)
	var i Stop
	err := row.Scan(
		&i.StopID,
		&i.StopName,
		&i.StopLat,
		&i.StopLon,
		&i.LocationType,
		&i.Geom,
	)
	return i, err
}

const getStopDepartures = `-- name: GetStopDepartures :many
SELECT st.stop_id::text                       AS id,
       cd.date::text                          AS date,
       st.arrival_time::text                  AS arrival,
       st.departure_time::text                AS departure,
       s.stop_name::text                      AS name,
       s.stop_lat::double precision           AS lat,
       s.stop_lon::double precision           AS lon,
       t.trip_headsign::text                  AS headsign,
       COALESCE(r.route_short_name, '')::text AS short_name,
       COALESCE(r.route_long_name, '')::text  AS long_name
FROM stop_times st
         INNER JOIN stops s ON st.stop_id = s.stop_id
         INNER JOIN trips t ON st.trip_id = t.trip_id
         INNER JOIN routes r ON t.route_id = r.route_id
         INNER JOIN calendar_dates cd ON t.service_id = cd.service_id
WHERE s.stop_id = $1
  AND cd.date IN (current_date, current_date + interval '1 day')
ORDER BY date,
         departure
LIMIT $2::bigint
`

type GetStopDeparturesParams struct {
	StopID string `json:"stop_id"`
	Lim    int64  `json:"lim"`
}

type GetStopDeparturesRow struct {
	ID        string  `json:"id"`
	Date      string  `json:"date"`
	Arrival   string  `json:"arrival"`
	Departure string  `json:"departure"`
	Name      string  `json:"name"`
	Lat       float64 `json:"lat"`
	Lon       float64 `json:"lon"`
	Headsign  string  `json:"headsign"`
	ShortName string  `json:"short_name"`
	LongName  string  `json:"long_name"`
}

func (q *Queries) GetStopDepartures(ctx context.Context, arg GetStopDeparturesParams) ([]GetStopDeparturesRow, error) {
	rows, err := q.db.Query(ctx, getStopDepartures, arg.StopID, arg.Lim)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStopDeparturesRow
	for rows.Next() {
		var i GetStopDeparturesRow
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Arrival,
			&i.Departure,
			&i.Name,
			&i.Lat,
			&i.Lon,
			&i.Headsign,
			&i.ShortName,
			&i.LongName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStops = `-- name: GetStops :many
select stop_id, stop_name, stop_lat, stop_lon, location_type, geom from stops limit 50
`

func (q *Queries) GetStops(ctx context.Context) ([]Stop, error) {
	rows, err := q.db.Query(ctx, getStops)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Stop
	for rows.Next() {
		var i Stop
		if err := rows.Scan(
			&i.StopID,
			&i.StopName,
			&i.StopLat,
			&i.StopLon,
			&i.LocationType,
			&i.Geom,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStopsNearby = `-- name: GetStopsNearby :many
select stop_id, stop_name, stop_lat, stop_lon, location_type, geom
from stops
where st_dwithin(
    geography(st_point(stop_lon, stop_lat)),
    geography(st_point($1::double precision, $2::double precision)),
    $3::double precision
)
order by st_distance(
    st_point(stop_lon, stop_lat),
    st_point($1::double precision, $2::double precision)
)
limit $4::bigint
`

type GetStopsNearbyParams struct {
	Lon    float64 `json:"lon"`
	Lat    float64 `json:"lat"`
	Radius float64 `json:"radius"`
	Lim    int64   `json:"lim"`
}

func (q *Queries) GetStopsNearby(ctx context.Context, arg GetStopsNearbyParams) ([]Stop, error) {
	rows, err := q.db.Query(ctx, getStopsNearby,
		arg.Lon,
		arg.Lat,
		arg.Radius,
		arg.Lim,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Stop
	for rows.Next() {
		var i Stop
		if err := rows.Scan(
			&i.StopID,
			&i.StopName,
			&i.StopLat,
			&i.StopLon,
			&i.LocationType,
			&i.Geom,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
